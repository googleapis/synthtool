# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
import sys

import json
from pathlib import Path
import shutil
from typing import Any, Dict, List
import yaml

import synthtool as s
from synthtool import _tracked_paths, log, shell
from synthtool.gcp.common import CommonTemplates, detect_versions
from synthtool.sources import templates

PathOrStr = templates.PathOrStr

PB2_HEADER = r"""(\# -\*- coding: utf-8 -\*-\n)(\# Generated by the protocol buffer compiler\.  DO NOT EDIT!.*?# source: .*?\.proto)"""
PB2_GRPC_HEADER = r"""(\# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!)
(import grpc)"""

LICENSE = """
# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License."""

IGNORED_VERSIONS: List[str] = []

SAMPLES_TEMPLATE_PATH = Path(CommonTemplates()._template_root) / "python_samples"

NOTEBOOK_TEMPLATE_PATH = (
    Path(CommonTemplates()._template_root) / "python_notebooks_testing_pipeline"
)


def fix_pb2_headers(*, proto_root: str = "**/*_pb2.py") -> None:
    s.replace(
        proto_root,
        PB2_HEADER,
        rf"\g<1>{LICENSE}\n\n\g<2>",  # change order to avoid stacking replacements
        flags=re.DOTALL | re.MULTILINE,
    )


def fix_pb2_grpc_headers(*, proto_root: str = "**/*_pb2_grpc.py") -> None:
    s.replace(
        proto_root,
        PB2_GRPC_HEADER,
        rf"{LICENSE}\n\n\g<1>\n\n\g<2>",  # add line breaks to avoid stacking replacements
    )


def _get_help(filename: str) -> str:
    """Function used by sample readmegen"""
    return shell.run([sys.executable, filename, "--help"]).stdout


def _get_sample_readme_metadata(sample_dir: Path) -> dict:
    sample_readme = sample_dir / "README.rst.in"

    sample_metadata = {}
    if sample_readme.exists():
        requirements = str(Path(sample_dir / "requirements.txt").resolve())
        log.debug(
            f"Installing requirements at {requirements} to generate {sample_readme}"
        )
        shell.run([sys.executable, "-m", "pip", "install", "-r", requirements])

        with open(sample_readme) as f:
            sample_metadata = yaml.load(f, Loader=yaml.SafeLoader)
        for sample in sample_metadata["samples"]:
            # add absolute path to metadata so `python foo.py --help` succeeds
            sample["abs_path"] = Path(sample_dir / (sample["file"])).resolve()

    return sample_metadata


def python_notebooks_testing_pipeline() -> None:
    in_client_library = Path("owlbot.py").exists()
    if in_client_library:
        excludes: List[str] = []
        _tracked_paths.add(NOTEBOOK_TEMPLATE_PATH)
        s.copy([NOTEBOOK_TEMPLATE_PATH], excludes=excludes)


def py_samples(
    *,
    root: PathOrStr = None,
    skip_readmes: bool = False,
    files_to_exclude: List[str] = [],
) -> None:
    """
    Find all samples projects and render templates.
    Samples projects always have a 'requirements.txt' file and may also have
    README.rst.in

    Args:
        root (Union[Path, str]): The samples directory root.
        skip_readmes (bool): If true, do not generate readmes.
        files_to_exclude(List[str]): defaults to empty, but if present, adds files to excludes list
    """
    in_client_library = Path("samples").exists() and Path("setup.py").exists()
    if root is None:
        if in_client_library:
            root = "samples"
        else:
            root = "."

    excludes = files_to_exclude

    # todo(kolea2): temporary exclusion until samples are ready to be migrated to new format
    excludes.append("README.md")

    # TODO(busunkim): Readmegen is disabled as it requires installing the sample
    # requirements in Synthtool. Sample Readmegen should be refactored to stop
    # relying on the output of `python sample.py --help`
    skip_readmes = True
    if skip_readmes:
        excludes.append("README.rst")
    t = templates.TemplateGroup(SAMPLES_TEMPLATE_PATH, excludes=excludes)

    t.env.globals["get_help"] = _get_help  # for sample readmegen

    for req in Path(root).glob("**/requirements.txt"):
        sample_project_dir = req.parent
        log.info(f"Generating templates for samples project '{sample_project_dir}'")

        excludes.append("**/*tmpl*")  # .tmpl. files are partial templates
        sample_readme_metadata: Dict[str, Any] = {}
        if not skip_readmes:
            sample_readme_metadata = _get_sample_readme_metadata(sample_project_dir)
            # Don't generate readme if there's no metadata
            if sample_readme_metadata == {}:
                excludes.append("**/README.rst")

        if Path(sample_project_dir / "noxfile_config.py").exists():
            # Don't overwrite existing noxfile configs
            excludes.append("**/noxfile_config.py")

        result = t.render(subdir=sample_project_dir, **sample_readme_metadata)
        _tracked_paths.add(result)
        s.copy([result], excludes=excludes)


def configure_previous_major_version_branches() -> None:
    """Configure releases from previous major version branches by editing
    `.github/release-please.yml`.

    The current library version is obtained from `version.py` in `google/**/version.py`,
    or the `setup.py`.

    Releases are configured for all previous major versions. For example,
    if the library version is currently 3.5.1, the release-please config
    will include v2, v1, and v0.
    """

    # In version.py:    __version__ = "1.5.2"
    # In setup.py:      version = "1.5.2"
    VERSION_REGEX = (
        r"(?:__)?version(?:__)?\s*=\s*[\"'](?P<major_version>\d)\.[\d\.]+[\"']"
    )
    version_paths = list(Path(".").glob("google/**/version.py")) + [Path("setup.py")]

    major_version = None

    for p in version_paths:
        match = re.search(VERSION_REGEX, Path(p).read_text())

        if match is not None:
            major_version = int(match.group("major_version"))
            break

    if major_version is None:
        raise RuntimeError(
            "Unable to find library version in files {} with regex {}".format(
                version_paths, VERSION_REGEX
            )
        )

    with open(".github/release-please.yml") as f:
        release_please_yml = yaml.load(f, Loader=yaml.SafeLoader)

    if major_version > 0 and "branches" not in release_please_yml:
        branches = []
        for version in range(major_version - 1, -1, -1):
            branches.append(
                {
                    "branch": f"v{version}",
                    "handleGHRelease": True,
                    "releaseType": "python",
                }
            )

        with open(".github/release-please.yml", "a") as f:
            # comments can't be expressed in PyYAML
            f.write(
                """# NOTE: this section is generated by synthtool.languages.python
# See https://github.com/googleapis/synthtool/blob/master/synthtool/languages/python.py\n"""
            )
            f.write(yaml.dump({"branches": branches}))


def owlbot_main() -> None:
    """Copies files from staging and template directories into current working dir.

    When there is no owlbot.py file, run this function instead.

    Depends on owl-bot copying into a staging directory, so your .Owlbot.yaml should
    look a lot like this:

        docker:
            image: docker pull gcr.io/cloud-devrel-public-resources/owlbot-python:latest

        deep-remove-regex:
            - /owl-bot-staging

        deep-copy-regex:
            - source: /google/cloud/video/transcoder/(.*)/.*-nodejs/(.*)
              dest: /owl-bot-staging/$1/$2

    Also, this function requires a default_version in your .repo-metadata.json.  Ex:
        "default_version": "v1",
    """

    clean_up_generated_samples = True

    try:
        # Load the default version defined in .repo-metadata.json.
        default_version = json.load(open(".repo-metadata.json", "rt")).get(
            "default_version"
        )
    except FileNotFoundError:
        default_version = None

    if default_version:
        for library in s.get_staging_dirs(default_version):
            if clean_up_generated_samples:
                shutil.rmtree("samples/generated_samples", ignore_errors=True)
                clean_up_generated_samples = False
            s.move([library], excludes=["setup.py", "README.rst", "docs/index.rst"])
        s.remove_staging_dirs()

        templated_files = CommonTemplates().py_library(
            microgenerator=True,
            versions=detect_versions(path="./google", default_first=True),
        )
        s.move(
            [templated_files], excludes=[".coveragerc"]
        )  # the microgenerator has a good coveragerc file

        py_samples(skip_readmes=True)

        # run format nox session for all directories which have a noxfile
        for noxfile in Path(".").glob("**/noxfile.py"):
            s.shell.run(["nox", "-s", "format"], cwd=noxfile.parent, hide_output=False)

    configure_previous_major_version_branches()


if __name__ == "__main__":
    owlbot_main()
